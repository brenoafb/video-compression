# -*- coding: utf-8 -*-
"""NoteCS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uTQyqHDka0SKU6Dl3QK8hFL291azWVQd
"""

#!pip install bitstring
#!pip install --upgrade Pillow

#%reload_ext autoreload
#%autoreload 2

"""Includes"""

import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
#from google.colab.patches import cv2_imshow
import bitstring as bs
from yuv_reader import read_yuv
from block_utils import *
from compression import *
from decompression import *
from img_utils import *
from coding import *
from file_utils import *
import io
import time

"""Informações sobre o vídeo: nome e dimensõe"""

filename = 'foreman_qcif.yuv'
width = 176
height = 144

frames = read_yuv(filename)#[:0]

quality = 95

block_size = 16
delta = 50
first_frame, residuals, motion_vectors = compress_sequence(frames, block_size, delta, quality= quality)

"""Códigos a seguir somente para testar as funções:

"""

filename = "video.vid"
writeFile(filename, first_frame, residuals, motion_vectors, quality= quality)

rec_first_frame, rec_residuals, rec_motion_vectors = readFile(filename)

#residuals

recovered = build_sequence(rec_first_frame, rec_residuals, rec_motion_vectors, block_size)

#%matplotlib inline
recovered = np.array(recovered)
for i in range(recovered.shape[0]):
  #plt.imshow(recovered[i,:,:])
  #plt.pause(0.03)
  pass

im = Image.fromarray(recovered[10])
im.show()
#im.save("resultL.png")

id = 10
im = Image.fromarray(frames[id])
im.show()
#im.save("frameL.png")

"""A partir daqui: feito usando só JPEG, sem vetores de movimento"""

def compress_sequence_res(frames, block_size, delta, quality = 95):
  '''
  Given a sequence of frames, compress it into residuals
  and motion vectors
  '''
  first_frame = frames[0]
  first_frame_jpeg_bytes = encodeToJpeg(first_frame, quality)
  first_frame_jpeg = decodeFromJpeg(first_frame_jpeg_bytes)
  prev_frame = first_frame_jpeg.astype(np.float32)
  residuals = []
  for (i, curr_frame) in enumerate(frames[1:]):
    print(i)
    residual = curr_frame.astype(np.float32) - prev_frame
    residual, m, M = scale_to_img(residual)
    residuals.append((residual, m, M))
    #print(residual_original)
    #prev_frame = curr_frame
    residuejpeg_bytes = encodeToJpeg(residual, quality)
    residuejpeg = decodeFromJpeg(residuejpeg_bytes)
    rec_residue = scale_from_img(residuejpeg, m, M)
    prev_frame = rec_residue + prev_frame
    prev_frame = np.around(prev_frame)
    prev_frame[prev_frame > 255] = 255
    prev_frame[prev_frame < 0] = 0

  return (first_frame, residuals)

#f = file object
def writeFrameJPEG(f, residual, vmin, vmax, residue=False, quality = 95):
  residual_jpg = encodeToJpeg(residual, quality)
  if residue:
    bs.Bits(int= int(vmin), length=16).tofile(f)
    bs.Bits(int= int(vmax), length=16).tofile(f)
  img = residual_jpg
  bs.Bits(uint= len(img), length=24).tofile(f)
  f.write(img)

def writeFileJPEG (filename, frames, quality = 95):
  with open(filename, "wb") as f:
    for frame in frames:
      writeFrameJPEG(f, frame, None, None, quality = quality)

def writeFileRES (filename, first_frame, residuals, quality = 95):
  with open(filename, "wb") as f:
    writeFrameJPEG(f, first_frame, None, None, quality= quality)
    for i in range(len(residuals)):
      writeFrameJPEG(f, residuals[i][0], residuals[i][1], residuals[i][2], residue=True, quality = quality)

filename_jpeg = "videoJPEG.vid"
writeFileJPEG(filename_jpeg, frames, quality= quality)

first_frame_res, residuals_res = compress_sequence_res(frames, block_size, delta, quality= quality)
filename_res = "videoRES.vid"
writeFileRES(filename_res, first_frame_res, residuals_res, quality= quality)

def build_sequence_res(frame, residuals):
  '''
  Given frame 0, build the entire sequence
  '''
  frames = [frame]
  prev_frame = None
  for (residual, m, M) in residuals:

    scaled_residual = scale_from_img(residual, m, M)
    #print(scaled_residual)

    if prev_frame is None:
      curr_frame = frame + scaled_residual
    else:
      curr_frame = prev_frame + scaled_residual
    curr_frame = np.around(curr_frame)
    curr_frame[curr_frame > 255] = 255
    curr_frame[curr_frame < 0] = 0
    frames.append(curr_frame.astype(np.uint8))
    prev_frame = curr_frame
  return np.array(frames)

num_blocks = 176//16 * 144//16

def readFileJPEG (filename):
  video_bytes = b''
  with open(filename, "rb") as f:
    video_bytes = f.read()

  rec_frames = []

  while (video_bytes != b''):
    rec_frame, video_bytes = getFrame(video_bytes, first=True)
    rec_frames.append(rec_frame)

  return rec_frames

def readFileRES (filename):
  video_bytes = b''
  with open(filename, "rb") as f:
    video_bytes = f.read()

  rec_residuals = []

  rec_first_frame, video_bytes = getFrameRES(video_bytes, first=True)

  while (video_bytes != b''):
    vmin_n, vmax_n, img_array, video_bytes = getFrameRES(video_bytes)
    rec_residuals.append((img_array, vmin_n, vmax_n))

  return rec_first_frame, rec_residuals

def getFrameRES(video_bytes, first=False):
  offset = 0

  if not first:
    vmin_n = int.from_bytes(video_bytes[offset: offset+2], byteorder='big', signed= True)
    vmax_n = int.from_bytes(video_bytes[offset+2:offset+4], byteorder='big', signed= True)
    offset = offset+4

  img_len = int.from_bytes(video_bytes[offset: offset+3], byteorder='big')
  offset = offset+3
  img_bytes = video_bytes[offset:img_len + offset]
  offset = img_len + offset

  img_array = decodeFromJpeg(img_bytes)

  if first:
    return img_array, video_bytes[offset:]

  else:
    return vmin_n, vmax_n, img_array, video_bytes[offset:]

rec_frames = readFileJPEG(filename_jpeg)

rec_first_frame_res, rec_residuals_res = readFileRES(filename_res)
recovered_res = build_sequence_res(rec_first_frame_res, rec_residuals_res)

id = 250

im = Image.fromarray(rec_frames[id])
im.show()
#im.save("Q{}/jpgonly.png".format(quality))
im2 = Image.fromarray(recovered_res[id])
im2.show()
#im2.save("Q{}/jpgres.png".format(quality))
im3 = Image.fromarray(recovered[id])
im3.show()
#im3.save("Q{}/result.png".format(quality))
im4 = Image.fromarray(frames[id])
im4.show()
#im4.save("Q{}/original.png".format(quality))

a = np.array_equal(rec_frames[id], recovered[id])
print(a)

"""Análise dos resultados"""

id = -1

im = Image.fromarray(residuals[id][0])
im.show()
#im.save("Q{}/residuoid.png".format(quality))

residuejpeg_bytes = encodeToJpeg(residuals[id][0], quality)
residuejpeg = decodeFromJpeg(residuejpeg_bytes)

im2 = Image.fromarray(residuejpeg)
im2.show()
#im2.save("residuojpg.png")

im3 = Image.fromarray(rec_residuals[id][0])
im3.show()
#im3.save("Q{}/residuojpg.png".format(quality))

a = np.array_equal(rec_residuals[id][0], residuejpeg)
print(a)

import os
total_pixels = 176*144*3
n_frames = 300
bd = 8
psnr = []
psnr_jpeg = []
psnr_res = []

filename_dec = "video.vid"
filename_jpeg = "videoJPEG.vid"
filename_res = "videoRES.vid"

bpf = os.stat(filename_dec).st_size*8/n_frames
size = os.stat(filename_dec).st_size

bpf_jpeg = os.stat(filename_jpeg).st_size*8/n_frames
size_jpeg = os.stat(filename_jpeg).st_size

bpf_res = os.stat(filename_res).st_size*8/n_frames
size_res = os.stat(filename_res).st_size

mse = [np.sum((f.astype(np.int16) - r.astype(np.int16))**2)/total_pixels for r, f in zip(recovered, frames)]
mse_jpeg = [np.sum((f.astype(np.int16) - r.astype(np.int16))**2)/total_pixels for r, f in zip(rec_frames, frames)]
mse_res = [np.sum((f.astype(np.int16) - r.astype(np.int16))**2)/total_pixels for r, f in zip(recovered_res, frames)]
for i in range(len(mse)):
  psnr.append(10 * np.log10((2**bd-1)**2/mse[i]))
  psnr_jpeg.append(10 * np.log10((2**bd-1)**2/mse_jpeg[i]))
  psnr_res.append(10 * np.log10((2**bd-1)**2/mse_res[i]))

fig, ax = plt.subplots()
ax.plot(range(0, n_frames), psnr,label="Move Vector")
ax.plot(range(0, n_frames), psnr_jpeg,label="JPEG")
ax.plot(range(0, n_frames), psnr_res,label="Withour Move Vector")
ax.set_xlabel('frame_number')
ax.set_ylabel('PSNR')
ax.set_title('PSNR x frame_number')
ax.grid(True)
ax.legend()
#plt.savefig('Q{}/PSNR.png'.format(quality))
plt.show()

'''with open("Q{}/log.txt".format(quality), "w") as f:
  f.write("Nosso: " + str(bpf))
  f.write('\n')
  f.write("Só jpeg: " + str(bpf_jpeg))
  f.write('\n')
  f.write("Jpeg com resíduo: " + str(bpf_res))
  f.write('\n')'''

print(bpf, bpf_jpeg, bpf_res)